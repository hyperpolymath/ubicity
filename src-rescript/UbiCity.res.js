// Generated by ReScript, PLEASE EDIT WITH CARE

import * as $$Crypto from "crypto";
import * as Core__Array from "@rescript/core/src/Core__Array.res.js";
import * as Core__Option from "@rescript/core/src/Core__Option.res.js";

function make(latitude, longitude) {
  if (latitude >= -90.0 && latitude <= 90.0 && longitude >= -180.0 && longitude <= 180.0) {
    return {
            latitude: latitude,
            longitude: longitude
          };
  }
  
}

function isValid(coords) {
  if (coords.latitude >= -90.0 && coords.latitude <= 90.0 && coords.longitude >= -180.0) {
    return coords.longitude <= 180.0;
  } else {
    return false;
  }
}

var Coordinates = {
  make: make,
  isValid: isValid
};

function make$1(name, coordinates, type_, address, param) {
  if (name.length === 0) {
    return {
            TAG: "Error",
            _0: "Location name is required"
          };
  } else {
    return {
            TAG: "Ok",
            _0: {
              name: name,
              coordinates: coordinates,
              type: type_,
              address: address
            }
          };
  }
}

var $$Location = {
  make: make$1
};

function make$2(id, name, interests, param) {
  if (id.length === 0) {
    return {
            TAG: "Error",
            _0: "Learner ID is required"
          };
  } else {
    return {
            TAG: "Ok",
            _0: {
              id: id,
              name: name,
              interests: interests
            }
          };
  }
}

var Learner = {
  make: make$2
};

function make$3($$location, situation, connections, timeOfDay, param) {
  return {
          location: $$location,
          situation: situation,
          connections: connections,
          timeOfDay: timeOfDay
        };
}

var Context = {
  make: make$3
};

var Outcome = {
  empty: {
    success: undefined,
    connections_made: undefined,
    next_questions: undefined,
    artifacts: undefined
  }
};

function make$4(type_, description, domains, outcome, duration, intensity, param) {
  if (type_.length === 0) {
    return {
            TAG: "Error",
            _0: "Experience type is required"
          };
  } else if (description.length === 0) {
    return {
            TAG: "Error",
            _0: "Description is required"
          };
  } else {
    return {
            TAG: "Ok",
            _0: {
              type: type_,
              description: description,
              domains: domains,
              outcome: outcome,
              duration: duration,
              intensity: intensity
            }
          };
  }
}

var ExperienceData = {
  make: make$4
};

var Privacy = {
  makeAnonymous: {
    level: "anonymous",
    shareableWith: undefined
  }
};

var $$Crypto$1 = {};

function generateId() {
  var uuid = $$Crypto.randomUUID();
  return "ubi-" + uuid;
}

function make$5(id, timestamp, learner, context, experience, privacy, tags, versionOpt, param) {
  var version = versionOpt !== undefined ? versionOpt : "0.3.0";
  var id$1 = Core__Option.getOr(id, generateId());
  var timestamp$1 = Core__Option.getOr(timestamp, Date.now().toString());
  return {
          id: id$1,
          timestamp: timestamp$1,
          learner: learner,
          context: context,
          experience: experience,
          privacy: privacy,
          tags: tags,
          version: version
        };
}

var LearningExperience = {
  $$Crypto: $$Crypto$1,
  generateId: generateId,
  make: make$5
};

function findInterdisciplinary(experiences) {
  return experiences.filter(function (exp) {
              var domains = exp.experience.domains;
              if (domains !== undefined) {
                return domains.length > 1;
              } else {
                return false;
              }
            });
}

function groupByLocation(experiences) {
  return Core__Array.reduce(experiences, {}, (function (acc, exp) {
                var locationName = exp.context.location.name;
                var existing = Core__Option.getOr(acc[locationName], []);
                acc[locationName] = existing.concat([exp]);
                return acc;
              }));
}

function groupByLearner(experiences) {
  return Core__Array.reduce(experiences, {}, (function (acc, exp) {
                var learnerId = exp.learner.id;
                var existing = Core__Option.getOr(acc[learnerId], []);
                acc[learnerId] = existing.concat([exp]);
                return acc;
              }));
}

function calculateDiversity(experiences) {
  var domains = Core__Array.reduce(experiences, [], (function (acc, exp) {
          var doms = exp.experience.domains;
          if (doms !== undefined) {
            return acc.concat(doms);
          } else {
            return acc;
          }
        }));
  return Core__Array.reduce(domains, [], (function (acc, domain) {
                if (acc.includes(domain)) {
                  return acc;
                } else {
                  return acc.concat([domain]);
                }
              })).length;
}

var Analysis = {
  findInterdisciplinary: findInterdisciplinary,
  groupByLocation: groupByLocation,
  groupByLearner: groupByLearner,
  calculateDiversity: calculateDiversity
};

export {
  Coordinates ,
  $$Location ,
  Learner ,
  Context ,
  Outcome ,
  ExperienceData ,
  Privacy ,
  LearningExperience ,
  Analysis ,
}
/* crypto Not a pure module */
