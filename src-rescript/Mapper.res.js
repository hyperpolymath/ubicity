// Generated by ReScript, PLEASE EDIT WITH CARE

import * as UbiCity from "./UbiCity.res.js";
import * as Core__Array from "@rescript/core/src/Core__Array.res.js";
import * as StorageJs from "./storage.js";
import * as Core__Option from "@rescript/core/src/Core__Option.res.js";
import * as Core__Promise from "@rescript/core/src/Core__Promise.res.js";

function make(prim) {
  return new StorageJs.ExperienceStorage(prim);
}

var $$Storage = {
  make: make
};

function make$1(storageDirOpt, param) {
  var storageDir = storageDirOpt !== undefined ? storageDirOpt : "./ubicity-data";
  var storage = new StorageJs.ExperienceStorage(storageDir);
  var mapper_experiences = {};
  var mapper_indices = {
    location: {},
    domain: {},
    learner: {}
  };
  var mapper = {
    storage: storage,
    experiences: mapper_experiences,
    indices: mapper_indices
  };
  return Core__Promise.$$catch(storage.ensureDirectories().then(function () {
                  return Promise.resolve(mapper);
                }), (function (param) {
                return Promise.resolve(mapper);
              }));
}

function addToIndex(index, key, id) {
  var existing = Core__Option.getOr(index[key], []);
  if (existing.includes(id)) {
    return index;
  } else {
    index[key] = existing.concat([id]);
    return index;
  }
}

function updateIndices(mapper, experience) {
  var id = experience.id;
  var locationIndex = addToIndex(mapper.indices.location, experience.context.location.name, id);
  var domains = experience.experience.domains;
  var domainIndex = domains !== undefined ? Core__Array.reduce(domains, mapper.indices.domain, (function (acc, domain) {
            return addToIndex(acc, domain, id);
          })) : mapper.indices.domain;
  var learnerIndex = addToIndex(mapper.indices.learner, experience.learner.id, id);
  return {
          storage: mapper.storage,
          experiences: mapper.experiences,
          indices: {
            location: locationIndex,
            domain: domainIndex,
            learner: learnerIndex
          }
        };
}

function captureExperience(mapper, experience) {
  mapper.experiences[experience.id] = experience;
  var updated = updateIndices(mapper, experience);
  var experienceJs = {
    id: experience.id,
    timestamp: experience.timestamp,
    version: experience.version,
    learner: {
      id: experience.learner.id,
      name: experience.learner.name,
      interests: experience.learner.interests
    },
    context: {
      location: {
        name: experience.context.location.name,
        coordinates: experience.context.location.coordinates,
        type: experience.context.location.type,
        address: experience.context.location.address
      },
      situation: experience.context.situation,
      connections: experience.context.connections,
      timeOfDay: experience.context.timeOfDay
    },
    experience: {
      type: experience.experience.type,
      description: experience.experience.description,
      domains: experience.experience.domains,
      outcome: experience.experience.outcome,
      duration: experience.experience.duration,
      intensity: experience.experience.intensity
    },
    privacy: experience.privacy,
    tags: experience.tags
  };
  return Core__Promise.$$catch(updated.storage.saveExperience(experienceJs).then(function () {
                  return Promise.resolve({
                              TAG: "Ok",
                              _0: experience.id
                            });
                }), (function (param) {
                return Promise.resolve({
                            TAG: "Error",
                            _0: "Failed to save experience"
                          });
              }));
}

function getExperienceCount(mapper) {
  return Object.keys(mapper.experiences).length;
}

function loadAll(mapper) {
  return Core__Promise.$$catch(mapper.storage.loadAllExperiences().then(function (experiencesData) {
                  return Promise.resolve({
                              TAG: "Ok",
                              _0: experiencesData.length
                            });
                }), (function (param) {
                return Promise.resolve({
                            TAG: "Error",
                            _0: "Failed to load experiences"
                          });
              }));
}

function findInterdisciplinary(mapper) {
  var experiences = Object.values(mapper.experiences);
  return UbiCity.Analysis.findInterdisciplinary(experiences);
}

function groupByLocation(mapper) {
  var experiences = Object.values(mapper.experiences);
  return UbiCity.Analysis.groupByLocation(experiences);
}

function groupByLearner(mapper) {
  var experiences = Object.values(mapper.experiences);
  return UbiCity.Analysis.groupByLearner(experiences);
}

function calculateDiversity(mapper) {
  var experiences = Object.values(mapper.experiences);
  return UbiCity.Analysis.calculateDiversity(experiences);
}

function findByLocation(mapper, locationName) {
  var ids = mapper.indices.location[locationName];
  if (ids !== undefined) {
    return Core__Array.filterMap(ids.map(function (id) {
                    return mapper.experiences[id];
                  }), (function (x) {
                  return x;
                }));
  } else {
    return [];
  }
}

function findByDomain(mapper, domain) {
  var ids = mapper.indices.domain[domain];
  if (ids !== undefined) {
    return Core__Array.filterMap(ids.map(function (id) {
                    return mapper.experiences[id];
                  }), (function (x) {
                  return x;
                }));
  } else {
    return [];
  }
}

function findByLearner(mapper, learnerId) {
  var ids = mapper.indices.learner[learnerId];
  if (ids !== undefined) {
    return Core__Array.filterMap(ids.map(function (id) {
                    return mapper.experiences[id];
                  }), (function (x) {
                  return x;
                }));
  } else {
    return [];
  }
}

function getHotspots(mapper, limitOpt, param) {
  var limit = limitOpt !== undefined ? limitOpt : 10;
  return Object.entries(mapper.indices.location).map(function (param) {
                  return [
                          param[0],
                          param[1].length
                        ];
                }).toSorted(function (a, b) {
                return b[1] - a[1] | 0;
              }).slice(0, limit);
}

function getTopDomains(mapper, limitOpt, param) {
  var limit = limitOpt !== undefined ? limitOpt : 10;
  return Object.entries(mapper.indices.domain).map(function (param) {
                  return [
                          param[0],
                          param[1].length
                        ];
                }).toSorted(function (a, b) {
                return b[1] - a[1] | 0;
              }).slice(0, limit);
}

export {
  $$Storage ,
  make$1 as make,
  addToIndex ,
  updateIndices ,
  captureExperience ,
  getExperienceCount ,
  loadAll ,
  findInterdisciplinary ,
  groupByLocation ,
  groupByLearner ,
  calculateDiversity ,
  findByLocation ,
  findByDomain ,
  findByLearner ,
  getHotspots ,
  getTopDomains ,
}
/* UbiCity Not a pure module */
