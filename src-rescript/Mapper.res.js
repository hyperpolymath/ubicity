// Generated by ReScript, PLEASE EDIT WITH CARE

import * as UbiCity from "./UbiCity.res.js";
import * as Core__Array from "@rescript/core/src/Core__Array.res.js";
import * as StorageJs from "./storage.js";
import * as Core__Option from "@rescript/core/src/Core__Option.res.js";
import * as Core__Promise from "@rescript/core/src/Core__Promise.res.js";

function make(prim) {
  return new StorageJs.ExperienceStorage(prim);
}

var $$Storage = {
  make: make
};

function make$1(storageDirOpt, param) {
  var storageDir = storageDirOpt !== undefined ? storageDirOpt : "./ubicity-data";
  var storage = new StorageJs.ExperienceStorage(storageDir);
  var mapper_experiences = {};
  var mapper_indices = {
    location: {},
    domain: {},
    learner: {}
  };
  var mapper = {
    storage: storage,
    experiences: mapper_experiences,
    indices: mapper_indices
  };
  return Core__Promise.$$catch(storage.ensureDirectories().then(function () {
                  return Promise.resolve(mapper);
                }), (function (param) {
                return Promise.resolve(mapper);
              }));
}

function addToIndex(index, key, id) {
  var existing = Core__Option.getOr(index[key], []);
  if (existing.includes(id)) {
    return index;
  } else {
    index[key] = existing.concat([id]);
    return index;
  }
}

function updateIndices(mapper, experience) {
  var id = experience.id;
  var locationIndex = addToIndex(mapper.indices.location, experience.context.location.name, id);
  var domains = experience.experience.domains;
  var domainIndex = domains !== undefined ? Core__Array.reduce(domains, mapper.indices.domain, (function (acc, domain) {
            return addToIndex(acc, domain, id);
          })) : mapper.indices.domain;
  var learnerIndex = addToIndex(mapper.indices.learner, experience.learner.id, id);
  return {
          storage: mapper.storage,
          experiences: mapper.experiences,
          indices: {
            location: locationIndex,
            domain: domainIndex,
            learner: learnerIndex
          }
        };
}

function captureExperience(mapper, experience) {
  mapper.experiences[experience.id] = experience;
  var updated = updateIndices(mapper, experience);
  var experienceJs = {
    id: experience.id,
    timestamp: experience.timestamp,
    version: experience.version,
    learner: {
      id: experience.learner.id,
      name: experience.learner.name,
      interests: experience.learner.interests
    },
    context: {
      location: {
        name: experience.context.location.name,
        coordinates: experience.context.location.coordinates,
        type: experience.context.location.type,
        address: experience.context.location.address
      },
      situation: experience.context.situation,
      connections: experience.context.connections,
      timeOfDay: experience.context.timeOfDay
    },
    experience: {
      type: experience.experience.type,
      description: experience.experience.description,
      domains: experience.experience.domains,
      outcome: experience.experience.outcome,
      duration: experience.experience.duration,
      intensity: experience.experience.intensity
    },
    privacy: experience.privacy,
    tags: experience.tags
  };
  return Core__Promise.$$catch(updated.storage.saveExperience(experienceJs).then(function () {
                  return Promise.resolve({
                              TAG: "Ok",
                              _0: experience.id
                            });
                }), (function (param) {
                return Promise.resolve({
                            TAG: "Error",
                            _0: "Failed to save experience"
                          });
              }));
}

function getExperienceCount(mapper) {
  return Object.keys(mapper.experiences).length;
}

function loadAll(mapper) {
  return Core__Promise.$$catch(mapper.storage.loadAllExperiences().then(function (experiencesData) {
                  return Promise.resolve({
                              TAG: "Ok",
                              _0: experiencesData.length
                            });
                }), (function (param) {
                return Promise.resolve({
                            TAG: "Error",
                            _0: "Failed to load experiences"
                          });
              }));
}

function findInterdisciplinary(mapper) {
  var experiences = Object.values(mapper.experiences);
  return UbiCity.Analysis.findInterdisciplinary(experiences);
}

function groupByLocation(mapper) {
  var experiences = Object.values(mapper.experiences);
  return UbiCity.Analysis.groupByLocation(experiences);
}

function groupByLearner(mapper) {
  var experiences = Object.values(mapper.experiences);
  return UbiCity.Analysis.groupByLearner(experiences);
}

function calculateDiversity(mapper) {
  var experiences = Object.values(mapper.experiences);
  return UbiCity.Analysis.calculateDiversity(experiences);
}

function findByLocation(mapper, locationName) {
  var ids = mapper.indices.location[locationName];
  if (ids !== undefined) {
    return Core__Array.filterMap(ids.map(function (id) {
                    return mapper.experiences[id];
                  }), (function (x) {
                  return x;
                }));
  } else {
    return [];
  }
}

function findByDomain(mapper, domain) {
  var ids = mapper.indices.domain[domain];
  if (ids !== undefined) {
    return Core__Array.filterMap(ids.map(function (id) {
                    return mapper.experiences[id];
                  }), (function (x) {
                  return x;
                }));
  } else {
    return [];
  }
}

function findByLearner(mapper, learnerId) {
  var ids = mapper.indices.learner[learnerId];
  if (ids !== undefined) {
    return Core__Array.filterMap(ids.map(function (id) {
                    return mapper.experiences[id];
                  }), (function (x) {
                  return x;
                }));
  } else {
    return [];
  }
}

function getHotspots(mapper, limitOpt, param) {
  var limit = limitOpt !== undefined ? limitOpt : 10;
  return Object.entries(mapper.indices.location).map(function (param) {
                  return [
                          param[0],
                          param[1].length
                        ];
                }).toSorted(function (a, b) {
                return b[1] - a[1] | 0;
              }).slice(0, limit);
}

function getTopDomains(mapper, limitOpt, param) {
  var limit = limitOpt !== undefined ? limitOpt : 10;
  return Object.entries(mapper.indices.domain).map(function (param) {
                  return [
                          param[0],
                          param[1].length
                        ];
                }).toSorted(function (a, b) {
                return b[1] - a[1] | 0;
              }).slice(0, limit);
}

function generateReport(mapper) {
  var experiences = Object.values(mapper.experiences);
  var summary_totalExperiences = experiences.length;
  var summary_uniqueLocations = Object.keys(mapper.indices.location).length;
  var summary_uniqueDomains = Object.keys(mapper.indices.domain).length;
  var summary_uniqueLearners = Object.keys(mapper.indices.learner).length;
  var summary_interdisciplinaryExperiences = UbiCity.Analysis.findInterdisciplinary(experiences).length;
  var summary = {
    totalExperiences: summary_totalExperiences,
    uniqueLocations: summary_uniqueLocations,
    uniqueDomains: summary_uniqueDomains,
    uniqueLearners: summary_uniqueLearners,
    interdisciplinaryExperiences: summary_interdisciplinaryExperiences
  };
  var learningHotspots = Object.entries(mapper.indices.location).map(function (param) {
          var experienceIds = param[1];
          var locationExps = Core__Array.filterMap(experienceIds.map(function (id) {
                    return mapper.experiences[id];
                  }), (function (x) {
                  return x;
                }));
          var domains = Core__Array.reduce(Core__Array.reduce(locationExps, [], (function (acc, exp) {
                      var doms = exp.experience.domains;
                      if (doms !== undefined) {
                        return acc.concat(doms);
                      } else {
                        return acc;
                      }
                    })), [], (function (acc, d) {
                  if (acc.includes(d)) {
                    return acc;
                  } else {
                    return acc.concat([d]);
                  }
                }));
          var learners = Core__Array.reduce(locationExps.map(function (exp) {
                    return exp.learner.id;
                  }), [], (function (acc, id) {
                  if (acc.includes(id)) {
                    return acc;
                  } else {
                    return acc.concat([id]);
                  }
                }));
          return {
                  location: param[0],
                  count: experienceIds.length,
                  diversity: domains.length,
                  learners: learners.length,
                  domains: domains
                };
        }).toSorted(function (a, b) {
        return b.diversity - a.diversity | 0;
      });
  return Promise.resolve({
              TAG: "Ok",
              _0: {
                summary: summary,
                learningHotspots: learningHotspots
              }
            });
}

function mapByLocation(mapper) {
  var result = {};
  Object.entries(mapper.indices.location).forEach(function (param) {
        var experienceIds = param[1];
        var locationExps = Core__Array.filterMap(experienceIds.map(function (id) {
                  return mapper.experiences[id];
                }), (function (x) {
                return x;
              }));
        var coordinates = Core__Option.flatMap(locationExps.find(function (exp) {
                  return Core__Option.isSome(exp.context.location.coordinates);
                }), (function (exp) {
                return exp.context.location.coordinates;
              }));
        var domains = Core__Array.reduce(Core__Array.reduce(locationExps, [], (function (acc, exp) {
                    var doms = exp.experience.domains;
                    if (doms !== undefined) {
                      return acc.concat(doms);
                    } else {
                      return acc;
                    }
                  })), [], (function (acc, d) {
                if (acc.includes(d)) {
                  return acc;
                } else {
                  return acc.concat([d]);
                }
              }));
        result[param[0]] = {
          coordinates: coordinates,
          count: experienceIds.length,
          domains: domains
        };
      });
  return result;
}

function generateDomainNetwork(mapper) {
  var experiences = Object.values(mapper.experiences);
  var domainCounts = {};
  var coOccurrences = {};
  experiences.forEach(function (exp) {
        var domains = exp.experience.domains;
        if (domains !== undefined) {
          domains.forEach(function (d) {
                var count = Core__Option.getOr(domainCounts[d], 0);
                domainCounts[d] = count + 1 | 0;
              });
          domains.forEach(function (d1) {
                domains.forEach(function (d2) {
                      if (d1 >= d2) {
                        return ;
                      }
                      var key = d1 + "--" + d2;
                      var count = Core__Option.getOr(coOccurrences[key], 0);
                      coOccurrences[key] = count + 1 | 0;
                    });
              });
          return ;
        }
        
      });
  var nodes = Object.entries(domainCounts).map(function (param) {
        return {
                id: param[0],
                size: param[1]
              };
      });
  var edges = Object.entries(coOccurrences).map(function (param) {
        var parts = param[0].split("--");
        return {
                source: Core__Option.getOr(parts[0], ""),
                target: Core__Option.getOr(parts[1], ""),
                weight: param[1]
              };
      });
  return {
          nodes: nodes,
          edges: edges
        };
}

export {
  $$Storage ,
  make$1 as make,
  addToIndex ,
  updateIndices ,
  captureExperience ,
  getExperienceCount ,
  loadAll ,
  findInterdisciplinary ,
  groupByLocation ,
  groupByLearner ,
  calculateDiversity ,
  findByLocation ,
  findByDomain ,
  findByLearner ,
  getHotspots ,
  getTopDomains ,
  generateReport ,
  mapByLocation ,
  generateDomainNetwork ,
}
/* UbiCity Not a pure module */
