// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Caml from "rescript/lib/es6/caml.js";
import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Core__Array from "@rescript/core/src/Core__Array.res.js";
import * as Core__Option from "@rescript/core/src/Core__Option.res.js";

function getTimeOfDay(timestamp) {
  var date = new Date(timestamp);
  var hour = date.getHours();
  if (hour >= 6 && hour < 12) {
    return "Morning";
  } else if (hour >= 12 && hour < 18) {
    return "Afternoon";
  } else if (hour >= 18 && hour < 22) {
    return "Evening";
  } else {
    return "Night";
  }
}

function extractDomains(experiences) {
  return Core__Array.reduce(Core__Array.reduce(experiences, [], (function (acc, exp) {
                    var domains = exp.experience.domains;
                    if (domains !== undefined) {
                      return acc.concat(domains);
                    } else {
                      return acc;
                    }
                  })), [], (function (acc, domain) {
                if (acc.includes(domain)) {
                  return acc;
                } else {
                  return acc.concat([domain]);
                }
              }));
}

function analyzeByTimeOfDay(experiences) {
  var morningExps = [];
  var afternoonExps = [];
  var eveningExps = [];
  var nightExps = [];
  experiences.forEach(function (exp) {
        var tod = getTimeOfDay(exp.timestamp);
        switch (tod) {
          case "Morning" :
              morningExps.push(exp);
              return ;
          case "Afternoon" :
              afternoonExps.push(exp);
              return ;
          case "Evening" :
              eveningExps.push(exp);
              return ;
          case "Night" :
              nightExps.push(exp);
              return ;
          
        }
      });
  return {
          morning: [
            morningExps.length,
            extractDomains(morningExps)
          ],
          afternoon: [
            afternoonExps.length,
            extractDomains(afternoonExps)
          ],
          evening: [
            eveningExps.length,
            extractDomains(eveningExps)
          ],
          night: [
            nightExps.length,
            extractDomains(nightExps)
          ]
        };
}

function analyzeByDayOfWeek(experiences) {
  var days = [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ];
  var distribution = {};
  days.forEach(function (day) {
        distribution[day] = [
          0,
          []
        ];
      });
  experiences.forEach(function (exp) {
        var date = new Date(exp.timestamp);
        var dayIndex = date.getDay();
        var dayName = Core__Option.getOr(days[dayIndex], "Sunday");
        var match = Core__Option.getOr(distribution[dayName], [
              0,
              []
            ]);
        var domains = match[1];
        var doms = exp.experience.domains;
        var newDomains = doms !== undefined ? domains.concat(doms) : domains;
        distribution[dayName] = [
          match[0] + 1 | 0,
          newDomains
        ];
      });
  Object.keys(distribution).forEach(function (day) {
        var match = Core__Option.getOr(distribution[day], [
              0,
              []
            ]);
        var uniqueDomains = Core__Array.reduce(match[1], [], (function (acc, d) {
                if (acc.includes(d)) {
                  return acc;
                } else {
                  return acc.concat([d]);
                }
              }));
        distribution[day] = [
          match[0],
          uniqueDomains
        ];
      });
  return distribution;
}

function detectStreaks(experiences, minDaysOpt, param) {
  var minDays = minDaysOpt !== undefined ? minDaysOpt : 3;
  var sorted = experiences.toSorted(function (a, b) {
        var aDate = new Date(a.timestamp);
        var bDate = new Date(b.timestamp);
        if (Caml_obj.lessthan(aDate, bDate)) {
          return -1.0;
        } else {
          return 1.0;
        }
      });
  var streaks = [];
  var currentStreak = [];
  sorted.forEach(function (exp, i) {
        if (i === 0) {
          currentStreak.push(exp);
          return ;
        }
        var prevExp = Core__Option.getExn(sorted[i - 1 | 0], undefined);
        var prevDate = new Date(prevExp.timestamp);
        var currDate = new Date(exp.timestamp);
        var daysDiff = Math.floor((currDate.getTime() - prevDate.getTime()) / 86400000.0) | 0;
        if (daysDiff <= 1) {
          currentStreak.push(exp);
          return ;
        }
        if (currentStreak.length >= minDays) {
          var firstExp = Core__Option.getExn(currentStreak[0], undefined);
          var lastExp = Core__Option.getExn(currentStreak[currentStreak.length - 1 | 0], undefined);
          streaks.push({
                start: firstExp.timestamp,
                end_: lastExp.timestamp,
                days: currentStreak.length,
                experiences: currentStreak.length
              });
        }
        currentStreak.splice(0, currentStreak.length);
        currentStreak.push(exp);
      });
  if (currentStreak.length >= minDays) {
    var firstExp = Core__Option.getExn(currentStreak[0], undefined);
    var lastExp = Core__Option.getExn(currentStreak[currentStreak.length - 1 | 0], undefined);
    streaks.push({
          start: firstExp.timestamp,
          end_: lastExp.timestamp,
          days: currentStreak.length,
          experiences: currentStreak.length
        });
  }
  return streaks;
}

var TemporalAnalyzer = {
  analyzeByTimeOfDay: analyzeByTimeOfDay,
  analyzeByDayOfWeek: analyzeByDayOfWeek,
  detectStreaks: detectStreaks
};

function buildCollaborationNetwork(experiences) {
  var edges = {};
  var allLearners = [];
  experiences.forEach(function (exp) {
        var learnerId = exp.learner.id;
        allLearners.push(learnerId);
        var collaborators = exp.context.connections;
        if (collaborators !== undefined) {
          collaborators.forEach(function (collaborator) {
                var key = [
                      learnerId,
                      collaborator
                    ].toSorted(function (a, b) {
                        if (a < b) {
                          return -1.0;
                        } else {
                          return 1.0;
                        }
                      }).join("-");
                var count = Core__Option.getOr(edges[key], 0);
                edges[key] = count + 1 | 0;
                allLearners.push(collaborator);
              });
          return ;
        }
        
      });
  var uniqueLearners = Core__Array.reduce(allLearners, [], (function (acc, id) {
          if (acc.includes(id)) {
            return acc;
          } else {
            return acc.concat([id]);
          }
        }));
  var learnerCounts = {};
  experiences.forEach(function (exp) {
        var count = Core__Option.getOr(learnerCounts[exp.learner.id], 0);
        learnerCounts[exp.learner.id] = count + 1 | 0;
      });
  return {
          nodes: uniqueLearners.map(function (id) {
                return {
                        id: id,
                        experiences: Core__Option.getOr(learnerCounts[id], 0)
                      };
              }),
          edges: Object.entries(edges).map(function (param) {
                var parts = param[0].split("-");
                return {
                        source: Core__Option.getOr(parts[0], ""),
                        target: Core__Option.getOr(parts[1], ""),
                        weight: param[1]
                      };
              })
        };
}

function findMostCollaborative(experiences, topNOpt, param) {
  var topN = topNOpt !== undefined ? topNOpt : 10;
  var counts = {};
  experiences.forEach(function (exp) {
        var collaborators = exp.context.connections;
        if (collaborators === undefined) {
          return ;
        }
        if (collaborators.length <= 0) {
          return ;
        }
        var count = Core__Option.getOr(counts[exp.learner.id], 0);
        counts[exp.learner.id] = count + collaborators.length | 0;
      });
  return Object.entries(counts).toSorted(function (a, b) {
                return b[1] - a[1] | 0;
              }).slice(0, topN);
}

var CollaborativeNetworkAnalyzer = {
  buildCollaborationNetwork: buildCollaborationNetwork,
  findMostCollaborative: findMostCollaborative
};

function getLearnerDomains(experiences, learnerId) {
  return Core__Array.reduce(Core__Array.reduce(experiences.filter(function (exp) {
                      return exp.learner.id === learnerId;
                    }), [], (function (acc, exp) {
                    var domains = exp.experience.domains;
                    if (domains !== undefined) {
                      return acc.concat(domains);
                    } else {
                      return acc;
                    }
                  })), [], (function (acc, d) {
                if (acc.includes(d)) {
                  return acc;
                } else {
                  return acc.concat([d]);
                }
              }));
}

function getVisitedLocations(experiences, learnerId) {
  return Core__Array.reduce(experiences.filter(function (exp) {
                    return exp.learner.id === learnerId;
                  }).map(function (exp) {
                  return exp.context.location.name;
                }), [], (function (acc, loc) {
                if (acc.includes(loc)) {
                  return acc;
                } else {
                  return acc.concat([loc]);
                }
              }));
}

function jaccardSimilarity(set1, set2) {
  var intersection = set1.filter(function (x) {
        return set2.includes(x);
      }).length;
  var union = Core__Array.reduce(set1.concat(set2), [], (function (acc, x) {
          if (acc.includes(x)) {
            return acc;
          } else {
            return acc.concat([x]);
          }
        })).length;
  if (union === 0) {
    return 0.0;
  } else {
    return intersection / union;
  }
}

function recommendSimilarLearners(experiences, learnerId, topNOpt, param) {
  var topN = topNOpt !== undefined ? topNOpt : 5;
  var targetDomains = getLearnerDomains(experiences, learnerId);
  if (targetDomains.length === 0) {
    return [];
  }
  var allLearners = Core__Array.reduce(experiences.map(function (exp) {
            return exp.learner.id;
          }), [], (function (acc, id) {
          if (acc.includes(id)) {
            return acc;
          } else {
            return acc.concat([id]);
          }
        }));
  var similarities = allLearners.filter(function (id) {
            return id !== learnerId;
          }).map(function (otherLearnerId) {
          var otherDomains = getLearnerDomains(experiences, otherLearnerId);
          var similarity = jaccardSimilarity(targetDomains, otherDomains);
          return {
                  learnerId: otherLearnerId,
                  similarity: similarity,
                  sharedDomains: targetDomains.filter(function (d) {
                        return otherDomains.includes(d);
                      })
                };
        }).filter(function (r) {
        return r.similarity > 0.0;
      });
  return similarities.toSorted(function (a, b) {
                return Caml.float_compare(b.similarity, a.similarity);
              }).slice(0, topN);
}

function recommendLocations(experiences, learnerId, topNOpt, param) {
  var topN = topNOpt !== undefined ? topNOpt : 5;
  var learnerDomains = getLearnerDomains(experiences, learnerId);
  var visitedLocations = getVisitedLocations(experiences, learnerId);
  var locationExps = Core__Array.reduce(experiences, {}, (function (acc, exp) {
          var $$location = exp.context.location.name;
          var exps = Core__Option.getOr(acc[$$location], []);
          acc[$$location] = exps.concat([exp]);
          return acc;
        }));
  var scores = [];
  Object.entries(locationExps).forEach(function (param) {
        var locationName = param[0];
        if (visitedLocations.includes(locationName)) {
          return ;
        }
        var locationDomains = extractDomains(param[1]);
        var relevance = jaccardSimilarity(learnerDomains, locationDomains);
        if (relevance > 0.0) {
          scores.push({
                location: locationName,
                relevance: relevance,
                matchingDomains: learnerDomains.filter(function (d) {
                      return locationDomains.includes(d);
                    })
              });
          return ;
        }
        
      });
  return scores.toSorted(function (a, b) {
                return Caml.float_compare(b.relevance, a.relevance);
              }).slice(0, topN);
}

function recommendDomains(experiences, learnerId, topNOpt, param) {
  var topN = topNOpt !== undefined ? topNOpt : 5;
  var learnerDomains = getLearnerDomains(experiences, learnerId);
  var coOccurrences = {};
  experiences.forEach(function (exp) {
        var domains = exp.experience.domains;
        if (domains === undefined) {
          return ;
        }
        var hasLearnerDomain = domains.some(function (d) {
              return learnerDomains.includes(d);
            });
        if (hasLearnerDomain) {
          domains.forEach(function (d) {
                if (learnerDomains.includes(d)) {
                  return ;
                }
                var count = Core__Option.getOr(coOccurrences[d], 0);
                coOccurrences[d] = count + 1 | 0;
              });
          return ;
        }
        
      });
  return Object.entries(coOccurrences).toSorted(function (a, b) {
                  return b[1] - a[1] | 0;
                }).slice(0, topN).map(function (param) {
              return {
                      domain: param[0],
                      relevance: param[1]
                    };
            });
}

var RecommendationEngine = {
  getLearnerDomains: getLearnerDomains,
  getVisitedLocations: getVisitedLocations,
  jaccardSimilarity: jaccardSimilarity,
  recommendSimilarLearners: recommendSimilarLearners,
  recommendLocations: recommendLocations,
  recommendDomains: recommendDomains
};

export {
  getTimeOfDay ,
  extractDomains ,
  TemporalAnalyzer ,
  CollaborativeNetworkAnalyzer ,
  RecommendationEngine ,
}
/* No side effect */
