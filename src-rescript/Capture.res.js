// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Mapper from "./Mapper.res.js";
import * as UbiCity from "./UbiCity.res.js";
import * as Core__Float from "@rescript/core/src/Core__Float.res.js";
import * as Core__Promise from "@rescript/core/src/Core__Promise.res.js";
import * as Promises from "readline/promises";

function make(modeOpt, param) {
  var mode = modeOpt !== undefined ? modeOpt : "Quick";
  return {
          mode: mode,
          mapper: undefined
        };
}

function initialize(session) {
  return Core__Promise.$$catch(Mapper.make(undefined, undefined).then(function (mapper) {
                  return Promise.resolve({
                              TAG: "Ok",
                              _0: {
                                mode: session.mode,
                                mapper: mapper
                              }
                            });
                }), (function (param) {
                return Promise.resolve({
                            TAG: "Error",
                            _0: "Failed to initialize mapper"
                          });
              }));
}

var Process = {};

function make$1() {
  return Promises.createInterface({
              input: process.stdin,
              output: process.stdout
            });
}

var Readline = {
  make: make$1
};

async function captureLearner(readline, mode) {
  console.log("WHO learned?\n");
  var id = await readline.question("Learner ID (pseudonym): ");
  if (id.trim().length === 0) {
    return {
            TAG: "Error",
            _0: "Learner ID is required"
          };
  }
  var learnerId = id.trim();
  switch (mode) {
    case "Full" :
        var name = await readline.question("Full name (optional): ");
        var nameOpt = name.trim().length > 0 ? name.trim() : undefined;
        var interests = await readline.question("Interests (comma-separated, optional): ");
        var interestsOpt = interests.trim().length > 0 ? interests.split(",").map(function (prim) {
                  return prim.trim();
                }).filter(function (s) {
                return s.length > 0;
              }) : undefined;
        return UbiCity.Learner.make(learnerId, nameOpt, interestsOpt, undefined);
    case "Quick" :
    case "Template" :
        break;
    
  }
  return UbiCity.Learner.make(learnerId, undefined, undefined, undefined);
}

async function captureLocation(readline, mode) {
  var locationName = await readline.question("Location name: ");
  if (locationName.trim().length === 0) {
    return {
            TAG: "Error",
            _0: "Location name is required"
          };
  }
  var name = locationName.trim();
  switch (mode) {
    case "Full" :
        var hasCoords = await readline.question("Add GPS coordinates? (y/n): ");
        var coords;
        if (hasCoords.toLowerCase() === "y") {
          var lat = await readline.question("Latitude: ");
          var lon = await readline.question("Longitude: ");
          var match = Core__Float.fromString(lat);
          var match$1 = Core__Float.fromString(lon);
          coords = match !== undefined && match$1 !== undefined ? UbiCity.Coordinates.make(match, match$1) : undefined;
        } else {
          coords = undefined;
        }
        var locationType = await readline.question("Location type (makerspace/library/park/etc, optional): ");
        var typeOpt = locationType.trim().length > 0 ? locationType.trim() : undefined;
        return UbiCity.$$Location.make(name, coords, typeOpt, undefined, undefined);
    case "Quick" :
    case "Template" :
        break;
    
  }
  return UbiCity.$$Location.make(name, undefined, undefined, undefined, undefined);
}

async function captureContext(readline, mode) {
  console.log("\nWHERE did learning happen?\n");
  var locationResult = await captureLocation(readline, mode);
  if (locationResult.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: locationResult._0
          };
  }
  var $$location = locationResult._0;
  switch (mode) {
    case "Full" :
        var situation = await readline.question("Situation/context (optional): ");
        var situationOpt = situation.trim().length > 0 ? situation.trim() : undefined;
        var connections = await readline.question("Others involved (comma-separated, optional): ");
        var connectionsOpt = connections.trim().length > 0 ? connections.split(",").map(function (prim) {
                  return prim.trim();
                }).filter(function (s) {
                return s.length > 0;
              }) : undefined;
        return {
                TAG: "Ok",
                _0: UbiCity.Context.make($$location, situationOpt, connectionsOpt, undefined, undefined)
              };
    case "Quick" :
    case "Template" :
        break;
    
  }
  return {
          TAG: "Ok",
          _0: UbiCity.Context.make($$location, undefined, undefined, undefined, undefined)
        };
}

async function captureOutcome(readline) {
  console.log("\nOutcome (optional):\n");
  var success = await readline.question("Was it successful? (y/n/skip): ");
  var match = success.toLowerCase();
  var outcome;
  switch (match) {
    case "n" :
        var init = UbiCity.Outcome.empty;
        outcome = {
          success: false,
          connections_made: init.connections_made,
          next_questions: init.next_questions,
          artifacts: init.artifacts
        };
        break;
    case "y" :
        var init$1 = UbiCity.Outcome.empty;
        outcome = {
          success: true,
          connections_made: init$1.connections_made,
          next_questions: init$1.next_questions,
          artifacts: init$1.artifacts
        };
        break;
    default:
      outcome = UbiCity.Outcome.empty;
  }
  var match$1 = outcome.success;
  if (match$1 === undefined) {
    return outcome;
  }
  var connections = await readline.question("Unexpected connections made (optional): ");
  var connectionsMade = connections.trim().length > 0 ? [connections.trim()] : undefined;
  var questions = await readline.question("New questions emerged (optional): ");
  var nextQuestions = questions.trim().length > 0 ? [questions.trim()] : undefined;
  return {
          success: outcome.success,
          connections_made: connectionsMade,
          next_questions: nextQuestions,
          artifacts: outcome.artifacts
        };
}

async function captureExperience(readline, mode) {
  console.log("\nWHAT was learned?\n");
  var type_ = await readline.question("Type (experiment/workshop/observation/conversation/reading/making): ");
  if (type_.trim().length === 0) {
    return {
            TAG: "Error",
            _0: "Experience type is required"
          };
  }
  var description = await readline.question("Description: ");
  if (description.trim().length === 0) {
    return {
            TAG: "Error",
            _0: "Description is required"
          };
  }
  var domains = await readline.question("Domains/disciplines (comma-separated, optional but useful): ");
  var domainsOpt = domains.trim().length > 0 ? domains.split(",").map(function (prim) {
            return prim.trim();
          }).filter(function (s) {
          return s.length > 0;
        }) : undefined;
  switch (mode) {
    case "Full" :
        var outcome = await captureOutcome(readline);
        var intensity = await readline.question("Intensity (low/medium/high, optional): ");
        var match = intensity.trim().toLowerCase();
        var intensityOpt;
        switch (match) {
          case "high" :
              intensityOpt = "high";
              break;
          case "low" :
              intensityOpt = "low";
              break;
          case "medium" :
              intensityOpt = "medium";
              break;
          default:
            intensityOpt = undefined;
        }
        return UbiCity.ExperienceData.make(type_.trim(), description.trim(), domainsOpt, outcome, undefined, intensityOpt, undefined);
    case "Quick" :
    case "Template" :
        break;
    
  }
  return UbiCity.ExperienceData.make(type_.trim(), description.trim(), domainsOpt, undefined, undefined, undefined, undefined);
}

async function captureOptionalFields(readline) {
  console.log("\nOptional metadata:\n");
  var privacy = await readline.question("Privacy level (private/anonymous/public) [default: anonymous]: ");
  var match = privacy.trim().toLowerCase();
  var privacyOpt;
  switch (match) {
    case "private" :
        privacyOpt = {
          level: "private",
          shareableWith: undefined
        };
        break;
    case "public" :
        privacyOpt = {
          level: "public",
          shareableWith: undefined
        };
        break;
    default:
      privacyOpt = UbiCity.Privacy.makeAnonymous;
  }
  var tags = await readline.question("Tags (comma-separated, optional): ");
  var tagsOpt = tags.trim().length > 0 ? tags.split(",").map(function (prim) {
            return prim.trim();
          }).filter(function (s) {
          return s.length > 0;
        }) : undefined;
  return [
          privacyOpt,
          tagsOpt
        ];
}

function generateTemplate(readline) {
  var template = {
    learner: {
      id: "your-pseudonym",
      name: "Your Name (optional)",
      interests: [
        "interest1",
        "interest2"
      ]
    },
    context: {
      location: {
        name: "Location Name",
        coordinates: {
          latitude: 0.0,
          longitude: 0.0
        },
        type: "makerspace"
      },
      situation: "What was happening",
      connections: [
        "person1",
        "person2"
      ]
    },
    experience: {
      type: "experiment",
      description: "What you learned",
      domains: [
        "domain1",
        "domain2"
      ],
      outcome: {
        success: true,
        connections_made: ["Unexpected insight"],
        next_questions: ["What question emerged?"]
      },
      duration: 60,
      intensity: "medium"
    },
    privacy: {
      level: "anonymous"
    },
    tags: [
      "tag1",
      "tag2"
    ]
  };
  var json = JSON.stringify(template);
  if (json !== undefined) {
    console.log(json);
  } else {
    console.log("Error: Could not generate template");
  }
  readline.close();
  return Promise.resolve();
}

async function capture(session) {
  var readline = make$1();
  console.log("\nüèôÔ∏è  UbiCity Learning Capture\n");
  var mode = session.mode;
  switch (mode) {
    case "Quick" :
    case "Full" :
        break;
    case "Template" :
        await generateTemplate(readline);
        return {
                TAG: "Ok",
                _0: "template-generated"
              };
    
  }
  var sessionResult = await initialize(session);
  if (sessionResult.TAG === "Ok") {
    var mapper = sessionResult._0.mapper;
    if (mapper !== undefined) {
      var learnerResult = await captureLearner(readline, mode);
      if (learnerResult.TAG === "Ok") {
        var contextResult = await captureContext(readline, mode);
        if (contextResult.TAG === "Ok") {
          var experienceResult = await captureExperience(readline, mode);
          if (experienceResult.TAG === "Ok") {
            var match;
            switch (mode) {
              case "Full" :
                  match = await captureOptionalFields(readline);
                  break;
              case "Quick" :
              case "Template" :
                  match = [
                    undefined,
                    undefined
                  ];
                  break;
              
            }
            var learningExperience = UbiCity.LearningExperience.make(undefined, undefined, learnerResult._0, contextResult._0, experienceResult._0, match[0], match[1], undefined, undefined);
            var saveResult = await Mapper.captureExperience(mapper, learningExperience);
            readline.close();
            if (saveResult.TAG !== "Ok") {
              return {
                      TAG: "Error",
                      _0: saveResult._0
                    };
            }
            var id = saveResult._0;
            console.log("\n‚úÖ Experience captured: " + id);
            var count = Mapper.getExperienceCount(mapper);
            console.log("üìä Total experiences: " + count.toString() + "\n");
            return {
                    TAG: "Ok",
                    _0: id
                  };
          }
          readline.close();
          return {
                  TAG: "Error",
                  _0: experienceResult._0
                };
        }
        readline.close();
        return {
                TAG: "Error",
                _0: contextResult._0
              };
      }
      readline.close();
      return {
              TAG: "Error",
              _0: learnerResult._0
            };
    }
    readline.close();
    return {
            TAG: "Error",
            _0: "Mapper not initialized"
          };
  }
  readline.close();
  return {
          TAG: "Error",
          _0: sessionResult._0
        };
}

var CaptureSession = {
  make: make,
  initialize: initialize,
  Process: Process,
  Readline: Readline,
  captureLearner: captureLearner,
  captureLocation: captureLocation,
  captureContext: captureContext,
  captureOutcome: captureOutcome,
  captureExperience: captureExperience,
  captureOptionalFields: captureOptionalFields,
  generateTemplate: generateTemplate,
  capture: capture
};

export {
  CaptureSession ,
}
/* Mapper Not a pure module */
